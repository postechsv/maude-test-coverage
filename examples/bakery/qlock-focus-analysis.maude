load ../tool2 .
load qlock .

mod MODEL is
  pr QLOCK .
  inc SATISFACTION .
  inc OBSERVATION .

  subsort Sys < State .

  vars I J : Pid . var S : Sys .
  vars Q R : Queue .

  --- Defining State Propositions ---
  op twoCrits : -> Prop [ctor] .
  eq (pc[I]: cs) (pc[J]: cs) S |= twoCrits = true .
  eq S |= twoCrits = false [owise] .

  op eq1LHS : -> Prop [ctor] .
  eq (pc[I]: rs) (queue: Q) (tmp[I]: R) |= eq1LHS = true .
  eq S |= eq1LHS = false [owise] .

  op eq2LHS : -> Prop [ctor] .
  eq (pc[I]: es) (queue: Q) (tmp[I]: R) |= eq2LHS = true .
  eq S |= eq2LHS = false [owise] .

  op wtLHS : -> Prop [ctor] .
  ceq (pc[I]: ws) (queue: Q) |= wtLHS = true if top(Q) = I .
  eq S |= wtLHS = false [owise] .

  op dq1LHS : -> Prop [ctor] .
  eq (pc[I]: cs) (queue: Q) (tmp[I]: R) |= dq1LHS = true .
  eq S |= dq1LHS = false [owise] .

  op dq2LHS : -> Prop [ctor] .
  eq (pc[I]: ds) (queue: Q) (tmp[I]: R) |= dq2LHS = true .
  eq S |= dq2LHS = false [owise] .

  --- Focus IDs ---
  ops f1 f2 : -> Pid .
  eq f1 = p1 .  eq f2 = p2 .

  --- Focus/Star LHS Propositions ---
  ops eq1LHSF1 eq1LHSF2 eq1LHSStar : -> Prop [ctor] .
  eq  (pc[f1]: rs) (queue: Q) (tmp[f1]: R) |= eq1LHSF1 = true .
  eq  S |= eq1LHSF1 = false [owise] .
  
  eq  (pc[f2]: rs) (queue: Q) (tmp[f2]: R) |= eq1LHSF2 = true .
  eq  S |= eq1LHSF2 = false [owise] .
  
  ceq (pc[I]: rs) (queue: Q) (tmp[I]: R) |= eq1LHSStar = true
    if I =/= f1 and I =/= f2 .
  eq  S |= eq1LHSStar = false [owise] .

  ops eq2LHSF1 eq2LHSF2 eq2LHSStar : -> Prop [ctor] .
  eq  (pc[f1]: es) (queue: Q) (tmp[f1]: R) |= eq2LHSF1 = true .
  eq  S |= eq2LHSF1 = false [owise] .
  
  eq  (pc[f2]: es) (queue: Q) (tmp[f2]: R) |= eq2LHSF2 = true .
  eq  S |= eq2LHSF2 = false [owise] .
  
  ceq (pc[I]: es) (queue: Q) (tmp[I]: R) |= eq2LHSStar = true
    if I =/= f1 and I =/= f2 .
  eq  S |= eq2LHSStar = false [owise] .

  ops wtLHSF1 wtLHSF2 wtLHSStar : -> Prop [ctor] .
  ceq (pc[f1]: ws) (queue: Q) |= wtLHSF1 = true if top(Q) = f1 .
  eq  S |= wtLHSF1 = false [owise] .
  
  ceq (pc[f2]: ws) (queue: Q) |= wtLHSF2 = true if top(Q) = f2 .
  eq  S |= wtLHSF2 = false [owise] .
  
  ceq (pc[I]: ws) (queue: Q) |= wtLHSStar = true
    if I =/= f1 and I =/= f2 and top(Q) = I .
  eq  S |= wtLHSStar = false [owise] .

  ops dq1LHSF1 dq1LHSF2 dq1LHSStar : -> Prop [ctor] .
  eq  (pc[f1]: cs) (queue: Q) (tmp[f1]: R) |= dq1LHSF1 = true .
  eq  S |= dq1LHSF1 = false [owise] .
  
  eq  (pc[f2]: cs) (queue: Q) (tmp[f2]: R) |= dq1LHSF2 = true .
  eq  S |= dq1LHSF2 = false [owise] .
  
  ceq (pc[I]: cs) (queue: Q) (tmp[I]: R) |= dq1LHSStar = true
    if I =/= f1 and I =/= f2 .
  eq  S |= dq1LHSStar = false [owise] .

  ops dq2LHSF1 dq2LHSF2 dq2LHSStar : -> Prop [ctor] .
  eq  (pc[f1]: ds) (queue: Q) (tmp[f1]: R) |= dq2LHSF1 = true .
  eq  S |= dq2LHSF1 = false [owise] .
  
  eq  (pc[f2]: ds) (queue: Q) (tmp[f2]: R) |= dq2LHSF2 = true .
  eq  S |= dq2LHSF2 = false [owise] .
  
  ceq (pc[I]: ds) (queue: Q) (tmp[I]: R) |= dq2LHSStar = true
    if I =/= f1 and I =/= f2 .
  eq  S |= dq2LHSStar = false [owise] .
 
  --- Defining Observations ---
  eq obs(S) = < obsUpto(S,
    eq1LHSF1 ; eq1LHSF2 ; eq1LHSStar ;
    eq2LHSF1 ; eq2LHSF2 ; eq2LHSStar ;
    wtLHSF1 ; wtLHSF2 ; wtLHSStar ;
    dq1LHSF1 ; dq1LHSF2 ; dq1LHSStar ;
    dq2LHSF1 ; dq2LHSF2 ; dq2LHSStar ;
    twoCrits ) > .

  eq reward(< FV:FeatVec , (twoCrits : true) , FV':FeatVec >) = 1.0 .
  eq reward(MS:MDPState) = 0.0 [owise] .
  var P : Prop . var B : Bool .
  eq < FV:FeatVec , (P : B) , FV':FeatVec > |= P = B .
endm


mod QLOCK-TEST is
  protecting MODEL .
  op goal : -> Prop .
  eq goal = twoCrits .
  
  ops init2 init3 init4 init5 init : -> Sys .
  eq init2 = (pc[p1]: rs) (pc[p2]: rs) (queue: empty) (tmp[p1]: empty) (tmp[p2]: empty) .
  eq init3 = (pc[p1]: rs) (pc[p2]: rs) (pc[p3]: rs) (queue: empty) 
             (tmp[p1]: empty) (tmp[p2]: empty) (tmp[p3]: empty) .
  eq init4 = (pc[p1]: rs) (pc[p2]: rs) (pc[p3]: rs) (pc[p4]: rs) (queue: empty)
             (tmp[p1]: empty) (tmp[p2]: empty) (tmp[p3]: empty) (tmp[p4]: empty) .
  eq init5 = (pc[p1]: rs) (pc[p2]: rs) (pc[p3]: rs) (pc[p4]: rs) (pc[p5]: rs) (queue: empty)
             (tmp[p1]: empty) (tmp[p2]: empty) (tmp[p3]: empty) (tmp[p4]: empty) (tmp[p5]: empty) .

  --- init3
  eq init = init3 .

  --- init4
  --- eq init = init4 .

  --- init5
  --- eq init = init5 .
endm